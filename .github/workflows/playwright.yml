name: Playwright Tests
on:
  push:
    branches: [main, dev, stg, prod]
  pull_request:
    branches: [main, dev, stg, prod]

# Adding permissions to allow comment creation
permissions:
  contents: write
  pages: write
  id-token: write
  issues: write
  pull-requests: write

jobs:
  wait-test-url:
    runs-on: ubuntu-latest
    steps:
      - name: Waiting for 200 from the Vercel Preview
        uses: patrickedqvist/wait-for-vercel-preview@v1.3.1
        id: waitForPreview
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          max_timeout: 60
    outputs:
      deployment_url: ${{ steps.waitForPreview.outputs.url }}
  test:
    needs: wait-test-url
    env:
      BASE_URL: ${{ needs.wait-test-url.outputs.deployment_url }}
    timeout-minutes: 60
    runs-on: ubuntu-latest
    outputs:
      test_outcome: ${{ steps.test-outcome.outputs.outcome }}
      tests_passed: ${{ steps.collect-test-results.outputs.passed }}
      tests_failed: ${{ steps.collect-test-results.outputs.failed }}
      tests_flaky: ${{ steps.collect-test-results.outputs.flaky }}
      tests_skipped: ${{ steps.collect-test-results.outputs.skipped }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: lts/*
      - name: Install dependencies
        run: npm ci
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
      - name: Run Playwright tests
        run: npx playwright test
        continue-on-error: true
      - name: Collect test results
        id: collect-test-results
        if: always()
        run: |
          if [ -f "playwright-report/test-results.json" ]; then
            # Use jq if available
            if command -v jq >/dev/null 2>&1; then
              PASSED=$(jq '.stats.expected' playwright-report/test-results.json 2>/dev/null || echo 0)
              FAILED=$(jq '.stats.unexpected' playwright-report/test-results.json 2>/dev/null || echo 0)
              FLAKY=$(jq '.stats.flaky' playwright-report/test-results.json 2>/dev/null || echo 0)
              SKIPPED=$(jq '.stats.skipped' playwright-report/test-results.json 2>/dev/null || echo 0)
            else
              # Fallback to grep if jq is not available
              PASSED=$(grep -o '"expected":[0-9]\+' playwright-report/test-results.json | cut -d':' -f2 || echo 0)
              FAILED=$(grep -o '"unexpected":[0-9]\+' playwright-report/test-results.json | cut -d':' -f2 || echo 0)
              FLAKY=$(grep -o '"flaky":[0-9]\+' playwright-report/test-results.json | cut -d':' -f2 || echo 0)
              SKIPPED=$(grep -o '"skipped":[0-9]\+' playwright-report/test-results.json | cut -d':' -f2 || echo 0)
            fi
          else
            PASSED=0
            FAILED=0
            FLAKY=0
            SKIPPED=0
          fi

          echo "passed=${PASSED}" >> $GITHUB_OUTPUT
          echo "failed=${FAILED}" >> $GITHUB_OUTPUT
          echo "flaky=${FLAKY}" >> $GITHUB_OUTPUT
          echo "skipped=${SKIPPED}" >> $GITHUB_OUTPUT
      - name: Set test outcome
        id: test-outcome
        if: always()
        run: echo "outcome=${{ job.status }}" >> $GITHUB_OUTPUT
      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
  deploy:
    needs: test
    if: ${{ always() && needs.test.outputs.test_outcome != 'cancelled' }}
    runs-on: ubuntu-latest
    outputs:
      report_url: ${{ steps.folder-name.outputs.url }}
    steps:
      - uses: actions/checkout@v4
      - name: Download Playwright Report
        uses: actions/download-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
      - name: Generate folder name
        id: folder-name
        run: |
          # Get branch name or PR number
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PREFIX="pr-${{ github.event.pull_request.number }}"
          else
            # Get branch name, replace slashes with dashes
            BRANCH_NAME=$(echo ${GITHUB_REF#refs/heads/} | sed 's/\//-/g')
            PREFIX="${BRANCH_NAME}"
          fi

          # Generate timestamp in format YYYY-MM-DD-HHMMSS
          TIMESTAMP=$(date '+%Y-%m-%d-%H-%M-%S')

          # Create the folder name
          FOLDER_NAME="${PREFIX}/${TIMESTAMP}"
          echo "name=${FOLDER_NAME}" >> $GITHUB_OUTPUT

          # Create the report URL for GitHub Pages
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          REPORT_URL="https://${REPO_OWNER}.github.io/${REPO_NAME}/${FOLDER_NAME}/index.html"
          echo "url=${REPORT_URL}" >> $GITHUB_OUTPUT

          # Create the folder structure
          mkdir -p "${FOLDER_NAME}"
          cp -r playwright-report/* "${FOLDER_NAME}/"

          # Create or update an index.html in the root directory
          mkdir -p reports
          echo "<html><head><title>Playwright Test Reports</title></head><body>" > reports/index.html
          echo "<h1>Playwright Test Reports</h1>" >> reports/index.html
          echo "<p>Last updated $(date '+%Y-%m-%d %H:%M:%S')</p>" >> reports/index.html
          echo "<ul>" >> reports/index.html

          # Find all directories and create links
          find reports -mindepth 2 -type d | sort -r | while read dir; do
            DIR_PATH="${dir#reports/}"
            echo "<li><a href=\"${DIR_PATH}/index.html\">${DIR_PATH}</a></li>" >> reports/index.html
          done

          echo "</ul></body></html>" >> reports/index.html
      - name: Deploy to GitHub Pages
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          folder: playwright-report
          branch: gh-pages
          clean: false
  comment:
    needs: [test, deploy]
    if: ${{ always() && github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    steps:
      - name: Create or Update Comment
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const repoName = context.repo.repo;
            const owner = context.repo.owner;
            const reportUrl = '${{ needs.deploy.outputs.report_url }}';

            // Test summary from outputs
            const testsPassed = '${{ needs.test.outputs.tests_passed || 0 }}';
            const testsFailed = '${{ needs.test.outputs.tests_failed || 0 }}';
            const testsFlaky = '${{ needs.test.outputs.tests_flaky || 0 }}';
            const testsSkipped = '${{ needs.test.outputs.tests_skipped || 0 }}';

            const emogies = {
              passed: '✅',
              failed: '❌',
              flaky: '⚠️',
              skipped: '⏸️'
            };
            const testStatus = {
              passed: testsPassed > 0 ? `${emogies.passed} ${testsPassed}` : 'No tests passed',
              failed: testsFailed > 0 ? `${emogies.failed} ${testsFailed}` : 'No tests failed',
              flaky: testsFlaky > 0 ? `${emogies.flaky} ${testsFlaky}` : 'No flaky tests',
              skipped: testsSkipped > 0 ? `${emogies.skipped} ${testsSkipped}` : 'No tests skipped'
            };

            const commentBody = `## Playwright Test Results ${testsFailed > 0 ? ' ❌': ' ✅' }

            | Status | Count |
            | ------ | ----- |
            | Passed | ${testStatus.passed} |
            | Failed | ${testStatus.failed} |
            | Flaky | ${testStatus.flaky} |
            | Skipped | ${testStatus.skipped} |

            [View Full Test Report](${reportUrl})

            Last updated ${new Date().toLocaleString()}
            `;

            // Find existing comment if any
            const issue_number = context.issue.number;
            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo: repoName,
              issue_number
            });

            const botComment = comments.find(comment => {
              return comment.user.type === 'Bot' && comment.body.includes('Playwright Test Results');
            });

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner,
                repo: repoName,
                comment_id: botComment.id,
                body: commentBody
              });
              console.log(`Updated comment #${botComment.id}`);
            } else {
              // Create new comment
              const { data: newComment } = await github.rest.issues.createComment({
                owner,
                repo: repoName,
                issue_number,
                body: commentBody
              });
              console.log(`Created comment #${newComment.id}`);
            }
